<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.js webgl - lines - fat</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #000;
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            z-index: 100;
        }
        #info a {
            color: #00ffff;
        }
    </style>
</head>
<body>
    <div id="info"><a href="https://threejs.org" target="_blank">three.js</a> - fat lines raycasting</div>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js"
            }
        }
    </script>
    
    <script type="module">
        import * as THREE from 'three';

        let renderer, scene, camera;
        let lineSegments = [];
        let sphereInter, sphereOnLine;
        const pointer = new THREE.Vector2(Infinity, Infinity);
        const raycaster = new THREE.Raycaster();
        let clock = new THREE.Clock();

        init();
        animate();

        function init() {
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000);
            document.body.appendChild(renderer.domElement);

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.set(-40, 0, 60);
            camera.lookAt(0, 0, 0);

            // Create spheres for intersection visualization
            const sphereGeometry = new THREE.SphereGeometry(0.5, 16, 8);
            const sphereInterMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, depthTest: false });
            const sphereOnLineMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, depthTest: false });
            
            sphereInter = new THREE.Mesh(sphereGeometry, sphereInterMaterial);
            sphereOnLine = new THREE.Mesh(sphereGeometry, sphereOnLineMaterial);
            sphereInter.visible = false;
            sphereOnLine.visible = false;
            sphereInter.renderOrder = 10;
            sphereOnLine.renderOrder = 10;
            
            scene.add(sphereInter);
            scene.add(sphereOnLine);

            // Generate spiral curve points
            const points = [];
            for (let i = -50; i < 50; i++) {
                const t = i / 3;
                points.push(new THREE.Vector3(t * Math.sin(2 * t), t, t * Math.cos(2 * t)));
            }

            const curve = new THREE.CatmullRomCurve3(points);
            const divisions = 300;
            
            // Create fat line segments using cylinders
            for (let i = 0; i < divisions - 1; i++) {
                const t1 = i / divisions;
                const t2 = (i + 1) / divisions;
                
                const p1 = curve.getPoint(t1);
                const p2 = curve.getPoint(t2);
                
                const distance = p1.distanceTo(p2);
                const geometry = new THREE.CylinderGeometry(0.3, 0.3, distance, 8, 1);
                
                // Color based on position along curve
                const color = new THREE.Color();
                color.setHSL(t1, 1.0, 0.5);
                const material = new THREE.MeshBasicMaterial({ color: color });
                
                const cylinder = new THREE.Mesh(geometry, material);
                
                // Position and orient cylinder between points
                const midpoint = new THREE.Vector3().addVectors(p1, p2).multiplyScalar(0.5);
                cylinder.position.copy(midpoint);
                
                const direction = new THREE.Vector3().subVectors(p2, p1).normalize();
                const up = new THREE.Vector3(0, 1, 0);
                const quaternion = new THREE.Quaternion().setFromUnitVectors(up, direction);
                cylinder.quaternion.copy(quaternion);
                
                cylinder.userData.segmentIndex = i;
                cylinder.userData.color = color.clone();
                
                scene.add(cylinder);
                lineSegments.push(cylinder);
            }

            // Add spheres at intervals for dotted effect
            for (let i = 0; i < divisions; i += 3) {
                const t = i / divisions;
                const point = curve.getPoint(t);
                
                const color = new THREE.Color();
                color.setHSL(t, 1.0, 0.5);
                
                const sphereGeom = new THREE.SphereGeometry(0.4, 16, 12);
                const sphereMat = new THREE.MeshBasicMaterial({ color: color });
                const sphere = new THREE.Mesh(sphereGeom, sphereMat);
                sphere.position.copy(point);
                sphere.userData.isDot = true;
                sphere.userData.color = color.clone();
                
                scene.add(sphere);
                lineSegments.push(sphere);
            }

            // Event listeners
            document.addEventListener('pointermove', onPointerMove);
            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onPointerMove(event) {
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            
            // Rotate all line segments
            lineSegments.forEach(segment => {
                segment.rotation.y += delta * 0.1;
            });

            // Raycasting
            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObjects(lineSegments);

            // Reset all colors
            lineSegments.forEach(segment => {
                if (segment.userData.color) {
                    segment.material.color.copy(segment.userData.color);
                }
            });

            if (intersects.length > 0) {
                sphereInter.visible = true;
                sphereOnLine.visible = true;
                sphereInter.position.copy(intersects[0].point);
                sphereOnLine.position.copy(intersects[0].point);
                
                // Highlight intersected segment
                const hitObject = intersects[0].object;
                if (hitObject.userData.color) {
                    hitObject.material.color.copy(hitObject.userData.color).offsetHSL(0.3, 0, 0.2);
                }
                
                document.body.style.cursor = 'crosshair';
            } else {
                sphereInter.visible = false;
                sphereOnLine.visible = false;
                document.body.style.cursor = '';
            }

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
